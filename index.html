<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  <title></title>
<style>
html {
  height: 100%;
}
body {
  background-color: #ccc;
  margin: 0;
  height: 100%;
}
div {
  position: relative;
  width: 100%;
  height: 100%;
  background-color: #333;
}
div:not(.complete) img{
  -webkit-filter: drop-shadow(1px 1px 1px #333);
  filter:         drop-shadow(1px 1px 1px rgb(51,51,51,0.5));
}
img {
  position: absolute;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  top:0;
  left:0;
}
</style>  
</head>
<body>
<div></div>
<script>
;(function (){
  var body = document.body
  var div = document.querySelector("div")

  var rowCount = 5
  var colCount = 5
  var edgeList = [] // Ensures that no two edges are identical
  var topsList = [] // Ensures that pieces fit with the row above
  var piecesList = []
  var groups = {}
  var complete = false
 
  var width
  var height
  var neck
  var layer = 1
  var threshold = 100

  var img = new Image()
  img.onload = function() {
    var imgWidth = img.width
    var imgHeight = img.height
    width = imgWidth / colCount
    height = imgHeight / rowCount
    neck = width / 6

    createPuzzlePieces()
  };

  img.src = "raven.png"

  function createPuzzlePieces(me) {   
    var edge
      
    for(var row = 0; row < rowCount; row += 1) {
      for(var col = 0; col < colCount; col += 1) {
        createPuzzlePiece(row, col)
      }
    }

    function createPuzzlePiece(row, col) {
      var canvas = document.createElement('canvas')
      var context = canvas.getContext('2d');
      canvas.width = width + neck * 2.5
      canvas.height = height + neck * 2.5

      context.beginPath()
      context.moveTo(neck, height + neck)
      
      // LEFT
      if (!col) {
        // The left edge is flat
        context.lineTo(neck, neck)
      } else {
        // Use previous right edge
        upwardEdge(neck, height + neck, edge)
      }

      // TOP
      if (!row) {
        context.lineTo(width + neck, neck)
      } else {
       // Use previous bottom edge
        rightwardEdge(width + neck, neck, topsList[col])
      }

      // RIGHT
      if ((col + 1) === colCount) {
        context.lineTo(width + neck, height + neck)
      } else {
        // Create a new right edge
        edge = randomEdge()
        downwardEdge(width + neck, height + neck, edge)
      }

      // BOTTOM    
      if (row + 1 === rowCount) {
        context.lineTo(neck, height + neck)
      } else {
        // Create a new bottom edge       
        topsList[col] = randomEdge()
        leftwardEdge(width + neck, height + neck, topsList[col])
      }
      context.clip()

      createImg()

      function downwardEdge(x0, height, edge) {
        // {
        //   tilt: tilt
        // , slant: slant
        // , angle: angle
        // , curve: curve
        // }
        var x1 = x0 - edge.curve     // shoulder
        var x2 = x0 + edge.curve / 5 // chin
        var x3 = x0 + neck * 1.2     // crown

        var y0 = neck
        var ym = y0 + (height - y0) / 2 // adjusted with tilt
        var y1 = ym - neck / 2      // top of neck
        var y2 = ym + neck / 2      // bottom of neck
        var y3 = ym - neck * 2      // top of slant
        var y4 = ym + neck * 2      // foot of slant

        context.bezierCurveTo(
          x0, y0                   // no handle on corner
        , x1, y1 - edge.angle     // base of neck
        , x0, y1                  // upper neck point
        )
        context.bezierCurveTo(
          x2, y1 + edge.angle / 5 // chin side of neck
        , x3 - edge.slant, y3     // upper slant
        , x3, ym + edge.tilt      // top of head
        )
        context.bezierCurveTo(
          x3 + edge.slant, y4     // lower slant
        , x2, y2 + edge.angle / 5 // chin side of neck
        , x0, y2                  // lower neck point
        )
        context.bezierCurveTo(
          x1, y2 - edge.angle     // base of neck
        , x0, height              // no handle on corner
        , x0, height              // corner
        )
      }

      function upwardEdge(x0, height, edge) {
        var x1 = x0 - edge.curve     // shoulder
        var x2 = x0 + edge.curve / 5 // chin
        var x3 = x0 + neck * 1.2     // crown

        var y0 = neck
        var ym = y0 + (height - y0) / 2 // adjusted with tilt
        var y1 = ym - neck / 2   // top of neck
        var y2 = ym + neck / 2   // bottom of neck
        var y3 = ym - neck * 2      // top of slant
        var y4 = ym + neck * 2     // foot of slant

        //context.lineTo(x0, neck)

        context.bezierCurveTo(
          x0, height              // no handle on corner
        , x1, y2 - edge.angle     // base of neck
        , x0, y2                  // upper neck point
        )
        context.bezierCurveTo(
          x2, y2 + edge.angle / 5 // chin side of neck
        , x3 + edge.slant, y4     // lower slant
        , x3, ym + edge.tilt      // top of head
        )
        context.bezierCurveTo(
          x3 - edge.slant, y3     // upper slant
        , x2, y1 + edge.angle / 5 // chin side of neck
        , x0, y1                  // lower neck point
        )
        context.bezierCurveTo(
          x1, y1 - edge.angle     // base of neck
        , x0, y0                   // no handle on corner
        , x0, y0                   // corner
        )
      }
   
      function leftwardEdge(width, y0, edge) {
        var y1 = y0 - edge.curve     // shoulder
        var y2 = y0 + edge.curve / 5 // chin
        var y3 = y0 + neck * 1.2     // crown

        var x0 = neck
        var xm = x0 + (width - x0) / 2 // adjusted with tilt
        var x1 = xm - neck / 2   // top of neck
        var x2 = xm + neck / 2   // bottom of neck
        var x3 = xm - neck * 2      // top of slant
        var x4 = xm + neck * 2     // foot of slant

        context.bezierCurveTo(
          width, y0              // no handle on corner
        , x2 - edge.angle, y1     // base of neck
        , x2, y0                  // upper neck point
        )
        context.bezierCurveTo(
          x2 + edge.angle / 5, y2 // chin side of neck
        , x4, y3 + edge.slant     // lower slant
        , xm + edge.tilt, y3      // top of head
        )
        context.bezierCurveTo(
          x3, y3 - edge.slant     // upper slant
        , x1 + edge.angle / 5, y2 // chin side of neck
        , x1, y0                  // lower neck point
        )
        context.bezierCurveTo(
          x1 - edge.angle, y1     // base of neck
        , x0, y0                   // no handle on corner
        , x0, y0                  // corner
        )
      }

      function rightwardEdge(width, y0, edge) {
        var y1 = y0 - edge.curve     // shoulder
        var y2 = y0 + edge.curve / 5 // chin
        var y3 = y0 + neck * 1.2     // crown

        var x0 = neck
        var xm = x0 + (width - x0) / 2 // adjusted with tilt
        var x1 = xm - neck / 2      // top of neck
        var x2 = xm + neck / 2      // bottom of neck
        var x3 = xm - neck * 2      // top of slant
        var x4 = xm + neck * 2      // foot of slant

        context.bezierCurveTo(
          x0, y0                  // no handle on corner
        , x1 - edge.angle, y1     // base of neck
        , x1, y0                  // upper neck point
        )
        context.bezierCurveTo(
          x1 + edge.angle / 5, y2 // chin side of neck
        , x3, y3 - edge.slant     // lower slant
        , xm + edge.tilt, y3      // top of head
        )
        context.bezierCurveTo(
          x4, y3 + edge.slant     // upper slant
        , x2 + edge.angle / 5, y2 // chin side of neck
        , x2, y0                  // lower neck point
        )
        context.bezierCurveTo(
          x2 - edge.angle, y1     // base of neck
        , width, y0                  // no handle on corner
        , width, y0               // corner
        )
      }
   
      function createImg() {
        var piece = new Image()
        piecesList.push(piece)

        context.drawImage(img, -col*width + neck, -row*height + neck)

        piece.onload = function(){
          // append the new image to the page
          div.appendChild(piece)
          piece.locX = -col*width
          piece.locY = -row*height
          piece.id = row+"_"+col
          groups[piece.id] = [piece]

          context = null
          canvas = null       
        }

        piece.src = canvas.toDataURL()
      }
    }

    return piecesList
  }

  function randomEdge(topsList, column) {   
    var tilt
      , slant
      , angle
      , curve
      , edge

    do {
      tilt  =  6 - Math.floor(Math.random() * 11)
      slant =  6 - Math.floor(Math.random() * 11)
      angle =  6 - Math.floor(Math.random() * 11)
      curve = 14 + Math.floor(Math.random() * 11)
    } while (edgeExists())

    function edgeExists() {
      var unique = edgeList.every(function (edge) {
        if (edge.tilt !== tilt) {
          return true
        } else if (edge.slant !== slant) {
          return true
        } else if (edge.angle !== angle) {
          return true
        } else if (edge.curve !== curve) {
          return true
        }
        return false
      })

      return !unique
    }

    edge  = {
      tilt: tilt
    , slant: slant
    , angle: angle
    , curve: curve
    }

    edgeList.push(edge)

    if (topsList) {
      topsList[column] = edge
    }

    return edge
  }
  
  ;(function play(){
    body.ontouchstart = function (event) {
      event.preventDefault()
    }

    div.onmousedown = div.ontouchstart = startDrag
      
    function startDrag(event) {
      event.preventDefault() 
      body.onmousemove = body.ontouchmove = drag
      body.onmouseup = body.ontouchend = stopDrag

      var target = event.target
      if (target.nodeName.toLowerCase() !== "img") {
        return
      }

      var pieces = groups[target.id]
      var clickX = event.pageX
      var clickY = event.pageY
      var startXs = {}
      var startYs = {}


      ;(function setStartXAndY(){
        var id
        layer++
        pieces.forEach(function (piece) {
          id = piece.id
          startXs[id] = piece.offsetLeft - clickX
          startYs[id] = piece.offsetTop - clickY
          piece.style.zIndex = layer
        })
      })()
    
      function drag(event) {      
        var id
        pieces.forEach(function (piece) {
          id = piece.id
          piece.style.left = startXs[id] + event.pageX + "px"
          piece.style.top = startYs[id] + event.pageY + "px"
        })
      }
    
      function stopDrag(event) {
        var targetRect = target.getBoundingClientRect()
        var x = targetRect.left + target.locX
        var y = targetRect.top + target.locY
        var deltaX
          , deltaY
          , delta2

        piecesList.forEach(function (piece) {
          if (piece !== target) {
            rect = piece.getBoundingClientRect()

            if (intersects(rect, targetRect)) {
              deltaX = rect.left + piece.locX - x
              deltaY = rect.top + piece.locY - y
              delta2 = deltaX * deltaX + deltaY * deltaY

              if (delta2 < threshold) {
                addToGroup(target, piece, deltaX, deltaY)
              }
            }
          }

          //piece.style.zIndex = 0
        })

        body.onmousemove = body.ontouchmove = null
        body.onmouseup = body.ontouchend = null

        function intersects(r1, r2) {
          return !(r2.left > r1.right || 
                   r2.right < r1.left || 
                   r2.top > r1.bottom ||
                   r2.bottom < r1.top)
        }

        function addToGroup(target, piece, deltaX, deltaY) {
          var group1 = groups[piece.id]
          var group2 = groups[target.id]
          var left
            , top

          // Copy everything into group1, which becomes the shared array
          // and snap the pieces to those of group1
          group2.forEach(snapToGroup)
          snapToGroup(target)

          function snapToGroup(piece) {
            if (group1.indexOf(piece) < 0) {
              group1.push(piece)
              groups[piece.id] = group1

              piece.style.left = piece.offsetLeft + deltaX + "px"
              piece.style.top = piece.offsetTop + deltaY + "px"
            }
          }

          // The target has moved, but there may be more matches
          targetRect = target.getBoundingClientRect()
          x = targetRect.left + target.locX
          y = targetRect.top + target.locY

          if (group1.length === colCount * rowCount && !complete) {
            // The puzzle is complete
            complete = true
            div.classList.add("complete")
          }
        }
      }
    }
  })()
})()
</script>

</body>
</html>